# Руководство по внедрению предиктивного анализа усталости в систему мониторинга водителей

## 1. Введение и цели

Данное руководство описывает поэтапный процесс внедрения предиктивного анализа усталости водителей в существующую систему мониторинга без необходимости длительного обучения ИИ-моделей. Цель - создать работающий демонстрационный прототип для хакатона.

### Ожидаемые результаты

- Оптимизированная структура данных для хранения событий
- Система извлечения признаков из событий мониторинга
- Имитационная ИИ-модель для демонстрации предиктивного анализа
- Интерфейс отображения прогнозов и рекомендаций

## 2. Оптимизация структуры данных

### 2.1. Расширение таблицы DRIVER_EVENTS

Сейчас таблица DRIVER_EVENTS хранит все данные внутри METADATA в формате JSON. Для оптимизации необходимо:

1. **Определить часто используемые поля для анализа:**
   - EAR (значение открытости глаз)
   - Значения левого/правого глаза (LEFT_EAR, RIGHT_EAR)
   - Направление головы (HEAD_DIRECTION)
   - Обнаружение лица (FACE_DETECTED)
   - Источник данных (FEATURE_SOURCE)

2. **Добавить новые колонки в таблицу:**
   - Создайте SQL-запрос ALTER TABLE для добавления нужных колонок
   - Используйте соответствующие типы данных (FLOAT для EAR, VARCHAR для направления, BOOLEAN для обнаружения)
   - Добавьте индексы для часто используемых в поиске полей

3. **Обновите сущность Event:**
   - Добавьте новые поля в класс сущности
   - Создайте геттеры и сеттеры для новых полей
   - При необходимости добавьте аннотации JPA

### 2.2. Модификация логики сохранения событий

1. **Измените метод logEventWithMetadata:**
   - Извлекайте важные метрики из метаданных
   - Сохраняйте их в новые поля сущности
   - Удаляйте извлеченные поля из JSON перед сохранением
   - Храните в JSON только дополнительные или редко используемые данные

2. **Добавьте фильтрацию незначительных событий:**
   - Создайте метод для проверки значимости события
   - Фильтруйте нормальные состояния (не сохраняйте их)
   - Для сонливости - сохраняйте только если EAR значительно ниже нормы
   - Для отвлечения - сохраняйте только при изменении направления головы

## 3. Создание сервиса извлечения признаков

### 3.1. Разработка FeatureExtractor

Создайте сервис DriverFeatureExtractor, который будет:

1. **Извлекать признаки из событий для анализа:**
   - Получать последние события водителя (за 15-30 минут)
   - Рассчитывать различные метрики на основе этих событий
   - Нормализовать значения в диапазоне [0, 1]

2. **Рассчитывать следующие признаки:**
   - Минимальное/среднее значение EAR за период
   - Количество событий сонливости/отвлечения (нормализованное)
   - Продолжительность текущей сессии вождения
   - Фактор времени суток (циркадные ритмы)
   - Частота моргания (расчетная или имитация)

3. **Возвращать признаки в виде Map<String, Float>:**
   - Единый формат данных для передачи в ИИ-модель
   - Удобство добавления новых признаков в будущем

### 3.2. Реализация метода расчета фактора времени суток

Создайте метод calculateTimeOfDayFactor, который:

1. Получает текущее время (или время анализируемого события)
2. Возвращает коэффициент риска в зависимости от времени суток:
   - Ночь (2:00-6:00) → 1.0 (высокий риск)
   - День (14:00-16:00) → 0.7 (послеобеденная сонливость)
   - Вечер (20:00-2:00) → 0.5 (средний риск)
   - Утро (6:00-10:00) → 0.2 (низкий риск)
   - Другое время → 0.1 (минимальный риск)

## 4. Создание имитационной ИИ-модели

### 4.1. Создание интерфейса модели

Создайте интерфейс PredictionModel, определяющий:

1. Метод predict(Map<String, Float> features) для предсказания состояния
2. Метод train(List<TrainingDataPoint> trainingData) для имитации обучения
3. Метод должен возвращать FatiguePrediction с информацией о прогнозе

### 4.2. Создание класса FatiguePrediction

Создайте класс FatiguePrediction, содержащий:

1. Перечисление RiskLevel (LOW, MEDIUM, HIGH)
2. Поле probability - вероятность усталости (0-1)
3. Поле minutesUntilHigh - минуты до высокого риска
4. Поле recommendation - текстовая рекомендация
5. Геттеры и сеттеры для всех полей

### 4.3. Создание имитационной модели

Реализуйте MockAIFatiguePredictionModel, который:

1. **Использует предопределенные веса для признаков:**
   - Инициализируйте Map<String, Float> с весами для каждого признака
   - Веса должны отражать реальное влияние фактора на усталость

2. **Реализует метод predict:**
   - Рассчитывает взвешенную сумму значений признаков
   - Добавляет небольшую случайность для реалистичности
   - Определяет уровень риска и рекомендацию
   - Рассчитывает примерное время до высокого риска

3. **Имитирует обучение:**
   - Реализует метод train, который выводит в лог имитацию процесса
   - Незначительно меняет веса для имитации улучшения модели

### 4.4. Расчет времени до высокого риска

Реализуйте метод estimateTimeToHighRisk, который:

1. Получает текущую вероятность и признаки
2. Рассчитывает скорость нарастания усталости
3. Определяет остаток до порога высокого риска (0.6)
4. Возвращает примерное время в минутах

## 5. Интеграция с пользовательским интерфейсом

### 5.1. Создание сервиса аналитики

Создайте сервис DriverAnalyticsService, который:

1. Извлекает признаки с помощью FeatureExtractor
2. Получает предсказание от PredictionModel
3. Формирует аналитический отчет и рекомендации

### 5.2. Обновление контроллера диспетчера

Добавьте в DispatcherController:

1. Новый метод-обработчик для эндпоинта "/driver/{id}/prediction"
2. Вызов сервиса аналитики
3. Добавление результатов в модель для отображения

### 5.3. Создание страницы предсказания

Создайте шаблон Thymeleaf "driver_prediction.html", который:

1. Отображает общую информацию о водителе
2. Показывает уровень риска с цветовой индикацией
3. Отображает вероятность усталости (процент)
4. Показывает время до высокого риска
5. Выводит рекомендации для диспетчера

### 5.4. Добавление диаграмм для визуализации

Добавьте в страницу:

1. Круговую диаграмму для отображения вероятности
2. Гистограмму для визуализации вклада отдельных факторов
3. Используйте JavaScript-библиотеку Chart.js для рендеринга

### 5.5. Добавление ссылок на прогноз

Обновите страницу dispatcher_panel.html:

1. Добавьте кнопку "Прогноз" рядом с каждым водителем
2. Кнопка должна вести на страницу прогноза для конкретного водителя

## 6. Создание демонстрационного режима

### 6.1. Создание демонстрационного сервиса

Создайте AIModelDemoService для демонстрации:

1. Метод имитации обучения модели с визуальными "логами"
2. Метод генерации имитационных обучающих данных
3. Метод симуляции различных сценариев (бодрый, усталый, сонный водители)

### 6.2. Добавление демонстрационного контроллера

Создайте DemoController с методами:

1. Запуск имитации обучения
2. Симуляция различных сценариев
3. Предсказания для реальных водителей

### 6.3. Создание страницы демонстрации

Создайте шаблон "ai-demo.html", который:

1. Позволяет запустить "обучение" модели
2. Выводит "логи" процесса обучения
3. Позволяет выбрать сценарий для демонстрации
4. Отображает результаты предсказания

## 7. Подготовка к презентации

### 7.1. Демонстрационные сценарии

Подготовьте несколько готовых сценариев:

1. **Бодрый водитель:**
   - EAR > 0.25
   - Нет событий сонливости
   - Короткая продолжительность вождения

2. **Усталый водитель:**
   - EAR около 0.22
   - Несколько событий сонливости
   - Средняя продолжительность вождения

3. **Сонный водитель:**
   - EAR < 0.2
   - Много событий сонливости
   - Длительное вождение
   - Ночное время

### 7.2. Ключевые моменты для презентации

Подготовьте объяснения для жюри:

1. **Многофакторный анализ:**
   - Объясните, что система анализирует не только EAR, но и множество факторов
   - Подчеркните важность времени суток и продолжительности вождения

2. **Проактивность:**
   - Объясните, как система предсказывает будущее состояние
   - Покажите расчет времени до высокого риска

3. **Интерпретируемость:**
   - Продемонстрируйте, как система объясняет причины усталости
   - Покажите вклад каждого фактора в итоговую оценку

4. **Практическая польза:**
   - Объясните, как система помогает диспетчеру принимать решения
   - Подчеркните экономическую выгоду от предотвращения аварий

## 8. Рекомендации по реализации

### 8.1. Приоритет задач

1. Сначала оптимизируйте структуру данных
2. Затем реализуйте извлечение признаков
3. Создайте базовую имитационную модель
4. Интегрируйте с пользовательским интерфейсом
5. Добавьте демонстрационные функции

### 8.2. Упрощения для быстрой реализации

1. Используйте простые формулы для расчета вероятности
2. Прописывайте веса вручную, основываясь на логике предметной области
3. Генерируйте демонстрационные данные с ожидаемыми результатами
4. Начните с минимального набора признаков (3-5), затем расширяйте

### 8.3. Обеспечение качества демонстрации

1. Проверьте работу системы с разными входными данными
2. Убедитесь, что переходы между уровнями риска выглядят естественно
3. Добавьте небольшую случайность для реалистичности (±5%)
4. Подготовьте запасной план демонстрации на случай проблем с реальными данными

## 9. Заключение

Следуя этому руководству, вы сможете создать демонстрационную версию предиктивного анализа усталости водителей без необходимости длительного обучения ИИ-моделей. Эта имитационная модель послужит хорошей основой для будущей реализации настоящих ML-алгоритмов, когда вы накопите достаточно данных для обучения.

Помните, что для хакатона важнее продемонстрировать концепцию и потенциал системы, чем иметь полностью обученную модель машинного обучения.
